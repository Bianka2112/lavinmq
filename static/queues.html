<!DOCTYPE html>
<html>
  <head>
    <title>Queues | AvalancheMQ</title>
    <style>
      body { font-family: 'Monaco', monospace; }
      .sortable th { cursor: pointer; }
      table { border-collapse: collapse; width: 100%; }
      table th, table td { border: 1px solid #EEE; padding: 0.2em 0.3em }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>AvalancheMQ</h1>
      <div id="xhr-error"></div>
      <ul id="menu">
        <li><a href="/">Overview</a></li>
        <li><a href="/queues">Queues</a></li>
      </ul>
      <h2>
        Queues
        <small id="table-count"></small>
      </h2>
      <table id="table" class="sortable">
        <thead>
          <tr>
            <th>Name</th>
            <th>VHost</th>
            <th>Durable</th>
            <th>Messages</th>
            <th>Unacked</th>
            <th>Ready</th>
            <th>Consumers</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <script>
      var URL = "/api/queues";
      var keyColumns = ["name", "vhost"];
      var sortColumns = ["vhost", "name"];
      var reverseOrder = false;
      makeHeadersSortable();
      var raw = localStorage.getItem("queues", this.response);
      if (raw) updateTable(raw);
      fetchAndUpdate();
      var updateTimer = setInterval(fetchAndUpdate, 5000);

      function makeHeadersSortable() {
        var cells = document.getElementById("table").tHead.rows[0].cells;
        for (var i = 0; i < cells.length; i++) {
          cells[i].addEventListener("click", function (e) {
            var column = e.target.cellIndex;
            var newSortColumn = e.target.textContent.toLowerCase();
            if (sortColumns[0] === newSortColumn)
              reverseOrder = !reverseOrder;
            else
              sortColumns = [newSortColumn];
            clearInterval(updateTimer);
            var t = document.getElementById("table").tBodies[0];
            while (t.rows.length) t.deleteRow(0);
            var raw = localStorage.getItem("queues", this.response);
            updateTable(raw);
          });
        }
      }

      function fetchAndUpdate() {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', URL);
        xhr.onload = function(e) {
          document.getElementById("xhr-error").textContent = "";
          localStorage.setItem("queues", this.response);
          updateTable(this.response);
        }
        xhr.onerror = function(e) {
          document.getElementById("xhr-error").textContent = "Error fetching data";
        };
        xhr.ontimeout = function(e) {
          document.getElementById("xhr-error").textContent = "Error fetching data";
        };
        xhr.timeout = 5000;
        xhr.send();
      }

      function updateTable(raw) {
        var data = JSON.parse(raw);
        data.sort(function (a, b) {
          for (var i = 0; i < sortColumns.length; i++) {
            if (a[sortColumns[i]] > b[sortColumns[i]]) return 1 * (reverseOrder ? -1 : 1);
            if (a[sortColumns[i]] < b[sortColumns[i]]) return -1 * (reverseOrder ? -1 : 1);
          }
          return 0;
        });
        document.getElementById("table-count").textContent = data.length;
        var t = document.getElementById("table").tBodies[0];
        for (var i = 0; i < data.length; i++) {
          var queue = data[i];
          var foundIndex = findIndex(t.rows, i, queue);
          if (foundIndex !== -1) {
            var d = foundIndex - i;
            while (d--) t.deleteRow(i);

            var tr = t.rows[i];
            updateCell(tr, 3, queue.messages);
            updateCell(tr, 4, queue.unacked);
            updateCell(tr, 5, queue.ready);
            updateCell(tr, 6, queue.consumers);
          } else {
            var tr = t.insertRow(i);
            updateRow(tr, queue);
          }
        }

        var rowsToDelete = t.rows.length - data.length;
        while (0 < rowsToDelete--)
          t.deleteRow(t.rows.length - 1);
      }

      function findIndex(rows, start, queue) {
        for (var i = start; i < rows.length; i++) {
          for (var k = 0; k < keyColumns.length; k++) {
            if (rows[i].getAttribute(keyColumns[k]) !== queue[keyColumns[k]])
              break;
            else if (k === keyColumns.length - 1)
              return i;
          }
        }
        return -1;
      }

      function updateCell(tr, index, value) {
        var text = value.toString();
        var cell = tr.cells[index];
        if (cell.textContent !== text)
          cell.textContent = text;
      }

      function updateRow(tr, queue) {
        keyColumns.forEach(function (key) {
          tr.setAttribute(key, queue[key]);
        });
        tr.setAttribute("name", queue.name);
        tr.setAttribute("vhost", queue.vhost);
        appendTextCell(tr, queue.name);
        appendTextCell(tr, queue.vhost);
        appendTextCell(tr, queue.durable ? "âœ…" : "" );
        appendTextCell(tr, queue.messages);
        appendTextCell(tr, queue.unacked);
        appendTextCell(tr, queue.ready);
        appendTextCell(tr, queue.consumers);
      }

      function appendTextCell(tr, text) {
        tr.insertCell(-1).appendChild(document.createTextNode(text));
      }
    </script>
  </body>
</html>
