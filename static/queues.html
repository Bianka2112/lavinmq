<!DOCTYPE html>
<html>
  <head>
    <title>Queues | AvalancheMQ</title>
    <style>
      body { font-family: 'Menlo', monospace; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>AvalancheMQ</h1>
      <div id="xhr-error"></div>
      <ul id="menu">
        <li><a href="/">Overview</a></li>
        <li><a href="/queues">Queues</a></li>
      </ul>
      <h2>
        Queues
        <small id="queue-count"></small>
      </h2>
      <table id="queues">
        <thead>
          <tr>
            <th>Name</th>
            <th>VHost</th>
            <th>Durable</th>
            <th>Messages</th>
            <th>Unacked</th>
            <th>Ready</th>
            <th>Consumers</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <script>
      var t = document.getElementById("queues").tBodies[0];
      var sortColumns = ["vhost", "name"];
      var reverseOrder = false;
      updateQueues();
      setInterval(updateQueues, 5000);
      var theadCells = document.getElementById("queues").tHead.rows[0].cells;
      for (var i = 0; i < theadCells.length; i++) {
        var th = theadCells[i];
        th.addEventListener("click", function (e) {
          var newSortColumn = e.target.textContent.toLowerCase();
          if (sortColumns[0] === newSortColumn)
            reverseOrder = !reverseOrder;
          else
            sortColumns = [newSortColumn];
          console.log(sortColumns);
          console.log(reverseOrder);
        });
      }

      function reverseTable() {
        reverseOrder = !reverseOrder;
        console.log("reverseOrder", reverseOrder);
      }

      function updateQueues() {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/queues');
        xhr.onload = function(e) {
          document.getElementById("xhr-error").textContent = "";
          var data = JSON.parse(this.response).sort(function (a, b) {
            for (var i = 0; i < sortColumns.length; i++) {
              if (a[sortColumns[i]] > b[sortColumns[i]]) return 1 * (reverseOrder ? -1 : 1);
              if (a[sortColumns[i]] < b[sortColumns[i]]) return -1 * (reverseOrder ? -1 : 1);
            }
            return 0;
          });
          document.getElementById("queue-count").textContent = data.length;

          for (var i = 0; i < data.length; i++) {
            var queue = data[i];
            var foundIndex = findIndex(t.rows, i, queue);
            if (foundIndex !== -1) {
              var d = foundIndex - i;
              while (d--) t.deleteRow(i);

              var tr = t.rows[i];
              updateCell(tr, 3, queue.messages);
              updateCell(tr, 4, queue.unacked);
              updateCell(tr, 5, queue.ready);
              updateCell(tr, 6, queue.consumers);
            } else {
              var tr = t.insertRow(i);
              updateRow(tr, queue);
            }
          }

          var rowsToDelete = t.rows.length - data.length;
          while (0 < rowsToDelete--)
            t.deleteRow(t.rows.length - 1);
        }
        xhr.onerror = function(e) {
          document.getElementById("xhr-error").textContent = "Error fetching data";
        };
        xhr.ontimeout = function(e) {
          document.getElementById("xhr-error").textContent = "Error fetching data";
        };
        xhr.timeout = 5000;
        xhr.send();
      }

      function findIndex(rows, start, queue) {
        for (var i = start; i < rows.length; i++) {
          if (t.rows[i].getAttribute("name") === queue.name && t.rows[i].getAttribute("vhost") === queue.vhost)
            return i;
        }
        return -1;
      }

      function updateCell(tr, index, value) {
        var text = value.toString();
        var cell = tr.cells[index];
        if (cell.textContent !== text)
          cell.textContent = text;
      }

      function updateRow(tr, queue) {
        tr.setAttribute("name", queue.name);
        tr.setAttribute("vhost", queue.vhost);
        appendTextCell(tr, queue.name);
        appendTextCell(tr, queue.vhost);
        appendTextCell(tr, queue.durable ? "âœ…" : "" );
        appendTextCell(tr, queue.messages);
        appendTextCell(tr, queue.unacked);
        appendTextCell(tr, queue.ready);
        appendTextCell(tr, queue.consumers);
      }

      function appendTextCell(tr, text) {
        var td = tr.insertCell(-1);
        td.appendChild(document.createTextNode(text));
      }
    </script>
  </body>
</html>
